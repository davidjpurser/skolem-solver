

# This file was *autogenerated* from the file ./leapfrogging/stepcompute.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_50 = Integer(50); _sage_const_0 = Integer(0); _sage_const_100 = Integer(100); _sage_const_2 = Integer(2); _sage_const_20 = Integer(20); _sage_const_3 = Integer(3); _sage_const_10 = Integer(10)
from utils.lrs import lrs
from utils.subsequences import getCompanionMatrix
from utils.helper import optionalprint

# Computes minimum L such that lambda^L = 1 mod p LRS modulo p (fast). 
def ComputePeriod(f, p):
	Fpt = FiniteField(p)['t']; (t,) = Fpt._first_ngens(1)
	ff = Fpt(f)
	factorf, myPeriods = [fac for fac in factor(ff)], []
	if max([fac[_sage_const_1 ] for fac in factorf]) > _sage_const_1 :
		N = _sage_const_50 
		for tup in f.discriminant().factor():
			if p == tup[_sage_const_0 ]:
				N += tup[_sage_const_1 ]	
		ZZp = Zp(p, N)['y']; (y,) = ZZp._first_ngens(1)
		for fac in ZZp(f).factor():
			myPeriods.append(p**fac[_sage_const_0 ].degree() - _sage_const_1 )
	else:
		for fac in factorf:
			q = p**fac[_sage_const_0 ].degree()
			Fqt = FiniteField(q)['t2']; (t2,) = Fqt._first_ngens(1)
			myPeriods.append(Fqt(fac[_sage_const_0 ]).roots()[_sage_const_0 ][_sage_const_0 ].multiplicative_order())
	return lcm(myPeriods)


# Helper function to compute a S >= 1 such that u_{Sn} != 0
# Only use this function when all characteristic roots lie in Q_p! 

def FindStepforSplittingp(mylrs, options, p, ToKill = False, KillBound = _sage_const_0 , N = _sage_const_100 ):
	# N is the accuracy of the p-adic computations

	# The prime 2 needs a special treatment
	if p == _sage_const_2 :
		extraCoeff = _sage_const_2 
	else:
		extraCoeff = _sage_const_1 

	# f is the characteristic polynomial of the LRS.
	Z = ZZ['t']; (t,) = Z._first_ngens(1)
	f = Z(([_sage_const_1 ] + [-a for a in mylrs.recurrence])[::-_sage_const_1 ])

	L = ComputePeriod(f, p) * extraCoeff

	# Little protection against getting overly big jumps
	# The second argument describes the biggest allowed period
	optionalprint(options, lambda: "prime: " + str(p) + " period: " + str(L) + " Splitting case")
	if L == -_sage_const_1 :
		return _sage_const_0 
	QpN = Qp(p, N)
	Q = QpN['t']; (t,) = Q._first_ngens(1)

	Qpf = Q(([_sage_const_1 ] + [-a for a in mylrs.recurrence])[::-_sage_const_1 ])
	MyRoots = [a[_sage_const_0 ] for a in Qpf.roots()]
	if len(MyRoots) != mylrs.order:
		optionalprint(options, lambda: "Too few roots: Either the LRS is not simple or the p-adic accuracy is too low")
		return _sage_const_0 

	# Compute the coefficients of the polynomial exponential sum
	VanDerMonde = sage.matrix.special.vandermonde(MyRoots).transpose()
	Coefficients = 	VanDerMonde**-_sage_const_1  * vector(mylrs.initial)

	# Alla will be the list with v_p(a_j) for all possibly relevant a_j.
	Alla = []
	
	for k in range(mylrs.order * _sage_const_2 ):
		a = QpN(_sage_const_0 )
		for i in range(mylrs.order):
			a += Coefficients[i] * log(MyRoots[i]**L)**k/factorial(k)
		Alla.append(valuation(a))
	optionalprint(options, lambda: "The first 2k valuations of the a_j for " +str(p) +  ": " + str(Alla))
	# If the first k a_j are zero, then the sequence is the zero sequence. So, with high enough precision, this won't happen!
	for i in range(k):
		if Alla[i] == N:
			continue
		NewValuations = [Alla[j] - Alla[i] for j in range(i+_sage_const_1 , i + mylrs.order)]
		mypower = _sage_const_0 
		
		while True in [a <= _sage_const_0  for a in NewValuations]:
			mypower += _sage_const_1 
			NewValuations = [NewValuations[j] + j + _sage_const_1  for j in range(mylrs.order - _sage_const_1 )]
		return L* p**mypower
		# return (L * p^mypower, L, p, mypower)
	return _sage_const_0 

# Helper function to compute a S >= 1 such that u_{Sn} != 0
# This version can be used for all polynomials!
def FindStepforSmallp(mylrs, options, p, ToKill = False, KillBound = _sage_const_0 , N = _sage_const_100 ):

	# N is the accuracy of the p-adic computations
	maxk = N

	# The prime 2 needs a special treatment
	if p == _sage_const_2 :
		extraCoeff = _sage_const_2 
	else:
		extraCoeff = _sage_const_1 

	# f is the characteristic polynomial of the LRS.
	Z = ZZ['t']; (t,) = Z._first_ngens(1)
	f = Z(([_sage_const_1 ] + [-a for a in mylrs.recurrence])[::-_sage_const_1 ])

	L = ComputePeriod(f, p) * extraCoeff

	# Little protection against getting overly big jumps
	# The second argument describes the biggest allowed period
	optionalprint(options, lambda:"prime: " + str(p) + " period: " + str(L) + " Non-splitting case")
	if L == -_sage_const_1 :
		return _sage_const_0 
	

	cmp = matrix(mylrs.getCompanionMatrix())
	B = (cmp**L - _sage_const_1 )/p
	v = vector([_sage_const_0  for i in range(mylrs.order-_sage_const_1 )] + [_sage_const_1 ])
	w = vector(mylrs.initial[::-_sage_const_1 ]).column()


	d = [v * w]
	Bi = v
	for _ in range(_sage_const_1 , maxk):
		Bi = Bi *  B
		d.append(Bi * w)

	# d = [v * B^i * w for i in range(maxk)] # recomputing B^i each step is not great
	MyQp = Qp(p, N)
	Alla = []
	
	for j in range(_sage_const_2  * mylrs.order):
		a = _sage_const_0 
		for k in range(j, maxk):
			a += -stirling_number1(k, j)*(-_sage_const_1 )**j * p**k * d[k][_sage_const_0 ] / factorial(k)
		if a == _sage_const_0 :
			Alla.append(N)
		else:
			Alla.append(valuation(MyQp(a)))
	optionalprint(options, lambda: "The first 2k valuations of the a_j for " + str(p)+ ": " + str(Alla))
	# If the first k a_j are zero, then the sequence is the zero sequence. So, with high enough precision, this won't happen!
	for i in range(k):
		if Alla[i] == N:
			continue

		NewValuations = [Alla[j] - Alla[i] for j in range(i+_sage_const_1 , i + mylrs.order)]
		mypower = _sage_const_0 
		
		while True in [a <= _sage_const_0  for a in NewValuations]:
			mypower += _sage_const_1 
			NewValuations = [NewValuations[j] + j + _sage_const_1  for j in range(mylrs.order - _sage_const_1 )]
		optionalprint(options, lambda: ("Jump:", L * p**mypower))
		return L* p**mypower
		# return (L * p^mypower, L, p, mypower)
	return _sage_const_0 





def splitsCompletely(f, p, N = _sage_const_100 ):
	Fpt = FiniteField(p)['t']; (t,) = Fpt._first_ngens(1)
	for g in [h[_sage_const_0 ] for h in f.factor()]:
		if g.discriminant() % p == _sage_const_0 :
			return False
		else:
			if len(Fpt(g).roots()) != g.degree():
				return False
	return True

# This function assumes that u_0 = 0
# It searches for multiple primes p which each give rise to a m \ge 1 such that u_{mn} != for all n ge 1 
# Of course, the smallest possible m is returned
# So far, it only works on simple LRS

def stepComputeLRS(mylrs, options,  N = _sage_const_20 ):
	# N is the accuracy of the p-adic computations
	
	initialgcd = gcd(mylrs.initial)
	mylrs = lrs(mylrs.order, [a/initialgcd for a in mylrs.initial], mylrs.recurrence)

	Z = ZZ['t']; (t,) = Z._first_ngens(1)

	# f is the characteristic polynomial of the LRS.
	f = Z(([_sage_const_1 ] + [-a for a in mylrs.recurrence])[::-_sage_const_1 ])

	# Compute a suitable prime p for the p-adic arithmatic
	AllPrimes = Primes()
	pp = AllPrimes.first()
	
	# This will save the best bound and the prime for which it is found
	MyBestBound = (_sage_const_0 , _sage_const_0 )

	# These are the small primes from which the first estimates are computed
	MyPrimesAndBounds = []

	# Computing bounds for the initial set of primes.
	BoundForFirstStep = _sage_const_3  * _sage_const_2 **mylrs.order

	# Extra step when some Bound is very low.
	MinLp = _sage_const_0 
	while pp < BoundForFirstStep or len(MyPrimesAndBounds) == _sage_const_0 :
		if mylrs.recurrence[-_sage_const_1 ] % pp != _sage_const_0 :
			Lp = ComputePeriod(f, pp)
			if pp == _sage_const_2 :
				Lp *= _sage_const_2 
			MyPrimesAndBounds.append((pp, Lp))
			if MinLp == _sage_const_0  or Lp < MinLp:
				MinLp = Lp
			if pp > MinLp:
				break
		pp = AllPrimes.next(pp)

	# Compute steps for the primes with the best bounds. 
	# Loop is necessary if the step function fails at one point.
	MyPrimesAndBounds.sort(key=lambda tup: tup[_sage_const_1 ]) 
	ii = _sage_const_0 
	pTried = []
	while MyBestBound[_sage_const_0 ] == _sage_const_0  and not ii >= len(MyPrimesAndBounds):
		p, Lp = MyPrimesAndBounds[ii][_sage_const_0 ], MyPrimesAndBounds[ii][_sage_const_1 ]
		if splitsCompletely(f, p, N):
			MyBestBound = (FindStepforSplittingp(mylrs, options, p), p)
		else:
			MyBestBound = (FindStepforSmallp(mylrs, options, p), p)
		pTried.append(p)
		optionalprint(options, lambda: "First attempt for the prime " + str(p) + " gave the step " + str(MyBestBound[_sage_const_0 ]))
		ii += _sage_const_1 



	# Compute whether any other small prime is likely to give a small bound. 
	for i in range(ii, len(MyPrimesAndBounds)):
		p, Lp = MyPrimesAndBounds[i][_sage_const_0 ], MyPrimesAndBounds[i][_sage_const_1 ]
		if Lp >= _sage_const_2  * MyBestBound[_sage_const_0 ]:
			break
		if p in pTried: continue
		if splitsCompletely(f, p, N):
			StepForp = FindStepforSplittingp(mylrs, options, p, ToKill = True, KillBound = MyBestBound[_sage_const_0 ])
		else:
			StepForp = FindStepforSmallp(mylrs, options, p, ToKill = True, KillBound = MyBestBound[_sage_const_0 ])
		# print(p, StepForp)
		if StepForp < MyBestBound[_sage_const_0 ] and StepForp != _sage_const_0 :
			optionalprint(options, lambda: "Better step found with prime " + str(p) + " is " + str(StepForp))
			MyBestBound = (StepForp, p)
		
	# Compute if any other prime gives an even better step
	BoundForSecondStep = _sage_const_2  * MyBestBound[_sage_const_0 ]
	while pp < BoundForSecondStep:

		if mylrs.recurrence[-_sage_const_1 ] % pp != _sage_const_0  and ComputePeriod(f, pp) < BoundForSecondStep:
			if splitsCompletely(f, p, N):
				StepForp = FindStepforSplittingp(mylrs, options, pp, ToKill = True, KillBound = MyBestBound[_sage_const_0 ])
			else:
				StepForp = FindStepforSmallp(mylrs, options, pp, ToKill = True, KillBound = MyBestBound[_sage_const_0 ])

			if StepForp < MyBestBound[_sage_const_0 ] and StepForp != _sage_const_0 :
				optionalprint(options, lambda: "Better step found with prime " + str(pp) + " is " + str(StepForp))
				MyBestBound = (StepForp, pp)
				BoundForSecondStep = _sage_const_2  * MyBestBound[_sage_const_0 ]

		pp = AllPrimes.next(pp)


	jump, p = MyBestBound
	reasoning = {
		"type" : "standard",
	}

	if MyBestBound[_sage_const_0 ] != _sage_const_0 :
		return jump, p, reasoning
	else:
		raise Exception("Something went wrong in the Step function!")


# This function assumes that u_0 = 0
# It searches for multiple primes p which each give rise to a m \ge 1 such that u_{mn} != for all n ge 1 
# It uses the fast algorithm that is not always successful nor does always return the 
# So far, it only works on simple LRS
def stepComputeLRSFast(mylrs, options):
	
	# divide by the gcd of initial values
	initialgcd = gcd(mylrs.initial)
	mylrs = lrs(mylrs.order, [a/initialgcd for a in mylrs.initial], mylrs.recurrence)

	Z = ZZ['t']; (t,) = Z._first_ngens(1)

	# f is the characteristic polynomial of the LRS.
	f = Z(([_sage_const_1 ] + [-a for a in mylrs.recurrence])[::-_sage_const_1 ])

	# Compute constant coefficient
	constantCoefficient = f(_sage_const_0 )
	
	# Compute discriminant of char poly
	myDiscriminantPoly = f.discriminant()
	
	# Compute coincidence matrix
	myOrder = mylrs.order 
	valueList = mylrs.listn(_sage_const_2  * myOrder - _sage_const_1 )
	myCoincidenceMatrix = matrix([valueList[i : i + myOrder] for i in range(myOrder)])
	myDeterminantMatrix = myCoincidenceMatrix.determinant()
	# Compute a suitable prime p
	AllPrimes = Primes()
	pp = AllPrimes.first()
	
	# This will save the best bound and the prime for which it is found
	MyBestBound = (_sage_const_0 , _sage_const_0 )

	# These are the small primes from which the first estimates are computed
	MyPrimesAndBounds = []
	
	# Computing bounds for the initial set of primes.
	BoundForFirstStep = _sage_const_3  * _sage_const_2 **mylrs.order
	
	# Extra step when some bound is small.
	MinLp = _sage_const_0 
	while pp < BoundForFirstStep or len(MyPrimesAndBounds) == _sage_const_0 :
		if not (pp == _sage_const_2  or constantCoefficient % pp == _sage_const_0  or myDiscriminantPoly % pp == _sage_const_0  or myDeterminantMatrix % pp == _sage_const_0 ):
			Lp = ComputePeriod(f, pp)
			MyPrimesAndBounds.append((pp, Lp))
			optionalprint(options, lambda: (pp, Lp))
			if MinLp == _sage_const_0  or Lp < MinLp:
				MinLp = Lp
			if pp > _sage_const_2 *MinLp and pp > _sage_const_100 :
				break
		pp = AllPrimes.next(pp)

	# Compute steps for the primes with the best bounds. 
	# Loop is necessary if the step function fails at one point.
	
	# Sort to try the smallest possible periods first
	MyPrimesAndBounds.sort(key=lambda tup: tup[_sage_const_1 ])

	# Only attempt the first 10 primes. If they fail, the method most likely does not apply
	MyPrimesAndBounds = MyPrimesAndBounds[:_sage_const_10 ]
	
	for primeAndBound in MyPrimesAndBounds:
		pp, periodModp = primeAndBound
		
		# The upper bound is almost always correct. To save time, we will not iterate it explicitly. 
		# Consider switching to mylrs.getPos (need to test)
		modpSquared = mylrs.listn(periodModp+_sage_const_1 , modulo = pp**_sage_const_2 )[periodModp]
		if modpSquared != _sage_const_0 :
			optionalprint(options, lambda: "Step found with prime " + str(pp) + " is " + str(periodModp))
			return(periodModp, pp, {
				"type" : "fast",
				"reason": "Step found with prime " + str(pp) + " is " + str(periodModp)
				})


	raise Exception("Something went wrong in the fast step function!")

