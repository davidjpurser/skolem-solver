

# This file was *autogenerated* from the file ./utils/subsequences.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_10 = Integer(10); _sage_const_40 = Integer(40); _sage_const_20 = Integer(20)
import sys
from .lrs import lrs
from . import lrsreader 
from .linearset import LinearSet
import fileinput

# Methods for making subsequences 


def getCompanionMatrix(lrs):
	# Find the companion matrix
	matrix = lrs.getCompanionMatrix()
	A = MatrixSpace(IntegerRing(),lrs.order)(matrix)
	return A

def getAlgebraicCompanionMatrix(lrs):
	# Find the companion matrix over algebraic numbers
	matrix = lrs.getCompanionMatrix()
	A = MatrixSpace(QQbar,lrs.order)(matrix)
	return A


def charpolylrs(lrs):
	Z = ZZ['t']; (t,) = Z._first_ngens(1)
	return Z(([_sage_const_1 ] + [-a for a in lrs.recurrence])[::-_sage_const_1 ])


def getRecurrence(matrix):
	# get the recurrence from a matrix
	f = matrix.charpoly()
	lrsrecurrence = [-x for x in reversed(f.list())][_sage_const_1 :]
	return lrsrecurrence

def powermatrix(matrix, power):
	# take the power of a matrix
	return matrix**power

def getInitial(first, linearset, order):
	#get the initial set for a new lrs corresponding to the subsequence according to the linear set 
	# should be combined with a companion matrix taking linearset.period as the power
	return [first[i] for i in linearset.firstN(order)]

def resolveInitial(lst,factor):
	return [Integer(Integer(x)/Integer(factor)) for x in lst]


def factorIntoSteps(m):
	# This function has as input a positive integer m such that u_0 = 0 and u_{nm} != 0 for all n >= 1
	# It outputs a list of list of classes [(L, [a,...,])... ] such that a + b n needs to be checked for all n
	ListOfClasses = []
	Factorization = factor(m)[::-_sage_const_1 ] # Reversing for optimization
	Currentb = _sage_const_1 
	for primepower in Factorization:
		p = primepower[_sage_const_0 ]
		for power in range(primepower[_sage_const_1 ]):
			Newb = Currentb * p
			ListOfClasses.append((Newb, [i*Currentb for i in range(_sage_const_1 , p)]))
			Currentb = Newb
	return ListOfClasses

def findBetterBoundRootOfUnity(n):
	# Computes a better bound on the largest possible root of unity.
	Factorization = factor(n)
	Newn = _sage_const_1 
	for Factor in Factorization:
		p, mult = Factor[_sage_const_0 ], Factor[_sage_const_1 ]
		Newn *= p**floor(log((mult + _sage_const_1 )/(p-_sage_const_1 ), p)+_sage_const_1 )
	# Include the second roots of unity if they are there yet
	if Newn % _sage_const_2  == _sage_const_1 :
		Newn *= _sage_const_2 
	return Newn
		
def isDegenerate(lrs):
	matrix = lrs.getCompanionMatrix()
	A = MatrixSpace(IntegerRing(),lrs.order)(matrix)
	
	f = A.charpoly()
	factors = [g[_sage_const_0 ] for g in list(factor(f))] 
	K = QQ['t']; (t,) = K._first_ngens(1)
	for f in factors: 
		x = K(f)
		# I hope this is correct!
		L = NumberField([y[_sage_const_0 ] for y in factor(x)], names=('a',)); (a,) = L._first_ngens(1)
		L = L.absolute_field(names=('b',)); (b,) = L._first_ngens(1)
		K = L['t']; (t,) = K._first_ngens(1)

	disc = abs(L.discriminant())

	# print("disc", disc)

	disc = findBetterBoundRootOfUnity(disc)

	# print("Better bound for roots of unity", disc)
	
	mt = getAlgebraicCompanionMatrix(lrs)
	roots = [f[_sage_const_0 ] for f in mt.charpoly().roots()]
	for i in range(len(roots)):
		for j in range(i):
			r1 = roots[i]
			r2 = roots[j]
			rat= r1/r2
			powered = rat**disc
			if ( powered == _sage_const_1 ):
				print("ratio of roots", r1,r2, rat, "is rou", rat**disc)
				return True
	return False

	

def isSimpleSage(mylrs):
	f = charpolylrs(mylrs)
	return gcd(f, f.derivative()).degree() == _sage_const_0 



def minimizeLRS(mylrs):
	# Find the minimal recurrence for a given LRS
	# Please do not input the zero LRS!

	firstFewValues = mylrs.listn(mylrs.order * _sage_const_2 )

	for i in range(mylrs.order, _sage_const_0 , -_sage_const_1 ):

		newMatrix = matrix([firstFewValues[j : i + j] for j in range(i)])

		# if linearlyIndependent the correct order is found
		if newMatrix.det() != _sage_const_0 :
			
			recurrence = list(newMatrix.inverse() * vector(firstFewValues[i : _sage_const_2 *i]))
			
			return lrs(i, firstFewValues[:i], recurrence[::-_sage_const_1 ])

	



### Testing
if __name__ == "__main__":

	mylrs = lrsreader.readLRS(lines)

	print(mylrs)
	print(mylrs.listn(_sage_const_10 ))

	matrix = getCompanionMatrix(mylrs)
	matrix2 = powermatrix(matrix,_sage_const_2  )
	print(matrix2)
	lrsrecurrence = getRecurrence(matrix2)
		
	print(mylrs.recurrence, lrsrecurrence)

	len = _sage_const_40 
	first = mylrs.listn(len)
	alternate = [first[i] for i in range(_sage_const_0 ,len,_sage_const_2 )]

	print("first",first)
	initial = getInitial(first, LinearSet(_sage_const_1 ,_sage_const_2 ), mylrs.order)
	print("alternate", alternate)
	print("initial", initial)

	secondlrs = lrs(mylrs.order, alternate[:mylrs.order] ,lrsrecurrence)
	print(secondlrs)
	print(secondlrs.listn(_sage_const_20 ))

