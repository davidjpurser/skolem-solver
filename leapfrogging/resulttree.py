
from utils.linearset import LinearSet
from utils import lrs


class ResultTree:
	# Data structure for the tree of LRS subsequences generated by the tool
	# Creates the dictionary object to return from the tool.


	def __init__(self, lrs, linearOfFullSet, linearOfParent):
		self.lrs = lrs
		self.actualLrs = lrs
		self.linearOfFullSet = linearOfFullSet
		self.linearOfParent = linearOfParent
		self.children = []
		self.type = None
		self.zero = 0 
		self.jump = 0
		self.modm = 0
		self.period = 0
		self.prime = 0
		self.reasoning = None

	def addChild(self,child):
		self.children.append(child)

	def isZero(self):
		return self.type == 'split'

	def setTypeZero(self, zeroIndex):
		self.type = 'split'
		self.zero = zeroIndex
		self.realZero = self.linearOfFullSet.mapNumberInto(self.zero)
		self.linearOfFullSet.setType("Z") # do these make sense?
		self.linearOfParent.setType("Z")

	def zeroAddJumpInfo(self,jump,p,reasoning):
		if self.type != 'split':
			raise Exception("adding zero jump info on wrong type")
		self.jump = jump
		self.prime = p
		self.reasoning = reasoning

	def setTypePAdicNonZero(self, zero, jump,p):
		self.type = 'padic-non-zero'
		self.zero = zero
		self.jump = jump
		self.prime = p
		self.linearOfFullSet.setType("Zne0")
		self.linearOfParent.setType("Zne0")

	def setTypeModM(self, modm, period):
		self.type = 'modm'
		self.modm = modm
		self.period = period
		self.linearOfFullSet.setType("Z")		
		self.linearOfParent.setType("Z")

	def getZeros(self):

		if self.type == 'split':
			yield self.realZero
		
		for child in self.children:
			yield from child.getZeros()

	def getAllChildren(self):
		yield self
		for x in self.children:
			yield from x.getAllChildren()

	def getSplitInfo(self):

		if self.type == 'split':
			yield (self.realZero, self.jump, self.prime)
		
		for child in self.children:
			yield from child.getSplitInfo()

	def getModuloInfo(self):

		if self.type == 'modm':
			yield (self.modm, self.period)

		for child in self.children:
			yield from child.getModuloInfo()


	def getDepth(self):

		childDepths = [0] + [x.getDepth() for x in self.children]
		return max(childDepths) + 1


	def getModMs(self):
		if self.type == 'modm':
			yield self.modm

		for child in self.children:
			yield from child.getModMs()

	def __str__(self):
		return self.getResultObject().__str__()

	def getResultObject(self,options =dict()):
		result = {}
		result['children'] = [child.getResultObject(options) for child in self.children]
		result['type'] = self.type
		result['linearOfFullSet'] = str(self.linearOfFullSet)
		result['linearOfParent'] = str(self.linearOfParent)

		lrsstr = str(self.lrs)
		if len(lrsstr) < 400 or (options.get('renderfull')):
			result['lrs'] = lrsstr
		else:
			result['lrs'] = 'suppressed due to large numbers'


		if self.lrs and  self.lrs.equals(self.actualLrs):
			result['actualLrs'] = 'same as LRS'
			result['isSame'] = True
		else:
			result['isSame'] = False
			actualLrsStr = str(self.actualLrs)
			if len(actualLrsStr) < 400 or (options.get('renderfull')):
				result['actualLrs'] = actualLrsStr
			else:
				result['actualLrs'] = 'suppressed due to large numbers'


		if self.type == 'padic-non-zero':
			result['zero'] = self.zero
			result['jump'] = self.jump


		if self.type == 'split':
			result['zero'] = self.zero
			result['jump'] = self.jump
			result['realzero'] = self.linearOfFullSet.mapNumberInto(self.zero)
			result['prime'] = self.prime
			result['reasoning'] = str(self.reasoning)

		if self.type == 'modm':
			result['modm'] = str(self.modm)
			seqmod =  self.actualLrs.getRepitionModuloList(self.modm)
			result['repmodm'] = [str(x) for x in seqmod]
			result['repmodmlen'] = len(seqmod) - self.actualLrs.order

		return result



